C51 COMPILER V9.54   MAIN                                                                  12/25/2023 21:32:13 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.l
                    -st) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include <stdlib.h>
   3          #include "Delay.h"
   4          #include "MatrixLED.h"
   5          #include "MatrixKey.h"
   6          #include "Timer0.h"
   7          
   8          unsigned char Direction,Length,KeyNum,Speed,Score;
   9          char Snake_x[11] = {0};//蛇身x坐标,理想状态是64，但单片机RAM不够，所以少设一些
  10          char Snake_y[11] = {0};//蛇身y坐标
  11          unsigned char code x[] = {0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe};
  12          unsigned char code y[] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
  13          unsigned char Food_x;//食物x坐标
  14          unsigned char Food_y;//食物y坐标
  15          
  16          
  17          unsigned char Independent_Key() //四个独立按键选择模式
  18          {
  19   1        static unsigned char KeyNumber_0;
  20   1        if(P3_1==0){KeyNumber_0=1;} //简单模式
  21   1        if(P3_0==0){KeyNumber_0=2;} //普通模式
  22   1        if(P3_2==0){KeyNumber_0=3;} //困难模式
  23   1        if(P3_3==0){KeyNumber_0=4;} //娱乐模式
  24   1        return KeyNumber_0;
  25   1      }
  26          
  27          
  28          void welcome()
  29          {
  30   1          unsigned char code welcome[]={
  31   1      0x00,0x40,0xC0,0xC0,0xCE,0x71,0x01,0x09,
  32   1      0x16,0x20,0x10,0x18,0x09,0x0A,0x0A,0x04,
  33   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  34   1      0x32,0x49,0x49,0x49,0x26,0x00,0x41,0x7F,
  35   1      0x41,0x00,0x7F,0x20,0x10,0x10,0x20,0x7F,
  36   1      0x00,0x7F,0x48,0x48,0x48,0x30,0x00,0x7F,
  37   1      0x01,0x01,0x01,0x00,0x7F,0x49,0x49,0x41,
  38   1      0x00,0x22,0x00,0x21,0x7F,0x01,0x00,0xFF,
  39   1      0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,0x7F,
  40   1      0x48,0x4C,0x4A,0x31,0x00,0x7F,0x41,0x41,
  41   1      0x41,0x3E,0x00,0x41,0x7F,0x41,0x00,0x7F,
  42   1      0x20,0x1C,0x02,0x7F,0x00,0x0F,0x34,0x44,
  43   1      0x34,0x0F,0x00,0x7F,0x48,0x4C,0x4A,0x31,
  44   1      0x00,0x40,0x20,0x1F,0x20,0x40,0x00,0x22,
  45   1      0x00,0x23,0x47,0x4D,0x59,0x31,0x00,0xFF,
  46   1      0x00,0x7F,0x41,0x41,0x41,0x3E,0x00,0x41,
  47   1      0x7F,0x41,0x00,0x7F,0x48,0x48,0x40,0x00,
  48   1      0x7F,0x48,0x48,0x40,0x00,0x41,0x7F,0x41,
  49   1      0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x7E,
  50   1      0x01,0x01,0x01,0x7E,0x00,0x7F,0x01,0x01,
  51   1      0x01,0x01,0x40,0x40,0x7F,0x40,0x40,0x00,
  52   1      0x40,0x20,0x1F,0x20,0x40,0x00,0x22,0x00,
  53   1      0x22,0x41,0x49,0x49,0x36,0x00,0xFF,0x00,
  54   1      0x7F,0x49,0x49,0x41,0x00,0x7F,0x20,0x1C,
C51 COMPILER V9.54   MAIN                                                                  12/25/2023 21:32:13 PAGE 2   

  55   1      0x02,0x7F,0x00,0x40,0x40,0x7F,0x40,0x40,
  56   1      0x00,0x7F,0x49,0x49,0x41,0x00,0x7F,0x48,
  57   1      0x4C,0x4A,0x31,0x00,0x40,0x40,0x7F,0x40,
  58   1      0x40,0x00,0x0F,0x34,0x44,0x34,0x0F,0x00,
  59   1      0x41,0x7F,0x41,0x00,0x7F,0x20,0x1C,0x02,
  60   1      0x7F,0x00,0x7F,0x20,0x10,0x10,0x20,0x7F,
  61   1      0x00,0x7F,0x49,0x49,0x41,0x00,0x7F,0x20,
  62   1      0x1C,0x02,0x7F,0x00,0x40,0x40,0x7F,0x40,
  63   1      0x40,0x00,0x22,0x00,0x0C,0x34,0x7F,0x04
  64   1      };
  65   1        unsigned char i,Offset = 0,Count = 0;
  66   1        MatrixLED_Init(); 
  67   1        while(1)  
  68   1        {
  69   2          {
  70   3            for(i = 0;i < 8;i++)
  71   3            {
  72   4              MatrixLED_ShowColumn(i,welcome[i + Offset]);
  73   4            }
  74   3            Count++;
  75   3            if(Count > 8)
  76   3            {
  77   4              Count = 0;
  78   4              Offset++;
  79   4              if(Offset > 256)
  80   4              {
  81   5                Offset = 0;
  82   5              }
  83   4            }     
  84   3          }
  85   2          if(Independent_Key() == 1 || Independent_Key() == 2 || Independent_Key() == 3 || Independent_Key() == 4)
  86   2          {
  87   3            break;
  88   3          }
  89   2        }
  90   1      }
  91          
  92          
  93          void Snake_move()//蛇身移动
  94          {
  95   1        unsigned char i;
  96   1        for (i = Length + 1; i > 0;i--)
  97   1        {
  98   2            Snake_x[i] = Snake_x[i - 1];//下一次的x坐标为上一次的x坐标，以实现向前挪动
  99   2            Snake_y[i] = Snake_y[i - 1];//同上
 100   2        }
 101   1        switch(Direction)//方向：1:上2:下3:左4:右
 102   1        {
 103   2          case 1:(Snake_y[0])--;break;
 104   2          case 2:(Snake_y[0])++;break;
 105   2          case 3:(Snake_x[0])--;break;
 106   2          case 4:(Snake_x[0])++;break;
 107   2        }
 108   1      }
 109          
 110          
 111          void Direction_key()//检测方向键，控制方向
 112          {
 113   1        if(KeyNum)
 114   1        {
 115   2          switch(KeyNum){
 116   3            case 1:if(Direction != 1)Direction = 2;break;//如果方向不是上，也就是方向为左或右，那么朝下
C51 COMPILER V9.54   MAIN                                                                  12/25/2023 21:32:13 PAGE 3   

 117   3            case 2:if(Direction != 2)Direction = 1;break;//同上
 118   3            case 3:if(Direction != 3)Direction = 4;break;//同上
 119   3            case 4:if(Direction != 4)Direction = 3;break;//同上
 120   3          }     
 121   2        }
 122   1      }
 123          
 124          
 125          void Food_coordinate()//食物坐标
 126          { 
 127   1        Food_x = rand() % 8;
 128   1        Food_y = rand() % 8;
 129   1      }
 130          
 131          
 132          void Refresh() //刷新蛇和食物的位置
 133          {
 134   1        unsigned char i;
 135   1        for(i = 0;i < Length;i++)
 136   1          {
 137   2            MatrixLED_Init();
 138   2            MatrixLED_ShowMove(x[Snake_x[i]],y[Snake_y[i]]);
 139   2            MatrixLED_Init();
 140   2            MatrixLED_ShowMove(x[Food_x],y[Food_y]);
 141   2          }
 142   1      }
 143          
 144          
 145          void Eat_food() //判断是否吃到食物
 146          {
 147   1        unsigned char i;
 148   1        for(i = 0;i < Length;i++)
 149   1        {
 150   2          if(Food_x == Snake_x[i] && Food_y == Snake_y[i])
 151   2          {
 152   3            Length++;
 153   3            Food_coordinate();
 154   3            Score++;
 155   3          }
 156   2        }
 157   1      }
 158          
 159          
 160          void Game_over() //游戏结束显示效果
 161          {
 162   1        unsigned char code Animation[] = {
 163   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 164   1      0x7E,0x81,0x81,0x89,0x89,0x4E,0x00,0x1F,
 165   1      0x68,0x88,0x68,0x1F,0x00,0xFF,0x40,0x20,
 166   1      0x20,0x40,0xFF,0x00,0xFF,0x91,0x91,0x91,
 167   1      0x91,0x00,0x00,0x7E,0x81,0x81,0x81,0x81,
 168   1      0x7E,0x00,0xF0,0x0E,0x01,0x0E,0xF0,0x00,
 169   1      0xFF,0x91,0x91,0x91,0x91,0x00,0x7F,0x88,
 170   1      0x8C,0x8A,0x71,0x00,0x00,0x00,0x00,0xF2,
 171   1      0x97,0x92,0x02,0xF2,0x12,0x12,0x02,0xF2,
 172   1      0x02,0xF2,0x92,0x92,0x02,0xF2,0x42,0xB2,
 173   1      0x02,0x02,0x02,0xF2,0x02,0x82,0xF2,0x82,
 174   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
 175   1      };
 176   1        unsigned char i,Offset = 0,Count = 0;
 177   1        MatrixLED_Init();
 178   1        while(1)
C51 COMPILER V9.54   MAIN                                                                  12/25/2023 21:32:13 PAGE 4   

 179   1        {
 180   2          for(i = 0;i < 8;i++)
 181   2          {
 182   3            MatrixLED_ShowColumn(i,Animation[i + Offset]);
 183   3          }
 184   2          Count++;
 185   2          if(Count > 4)
 186   2          {
 187   3            Count = 0;
 188   3            Offset++;
 189   3            if(Offset > 88)
 190   3            {
 191   4              Offset = 0;
 192   4            }
 193   3          }
 194   2          if(Score == 0){P2_0 = 1;}
 195   2          if(Score == 1){P2_0 = 0;}
 196   2          if(Score == 2){P2_0 = 0;P2_1 = 0;}
 197   2          if(Score == 3){P2_0 = 0;P2_1 = 0;P2_2 = 0;}
 198   2          if(Score == 4){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;}
 199   2          if(Score == 5){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;P2_4 = 0;}
 200   2          if(Score == 6){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;P2_4 = 0;P2_5 = 0;}
 201   2          if(Score == 7){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;P2_4 = 0;P2_5 = 0;P2_6 = 0;}
 202   2          if(Score == 8){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;P2_4 = 0;P2_5 = 0;P2_6 = 0;P2_7 = 0;}
 203   2        }   
 204   1      }
 205          
 206          
 207          void Snake_death() //判断死亡
 208          {
 209   1        
 210   1        //撞自己
 211   1        unsigned char i;
 212   1        for(i = 4;i < Length;i++)
 213   1        {
 214   2          if(Snake_x[0] == Snake_x[i] && Snake_y[0] == Snake_y[i])
 215   2          {     
 216   3            Game_over();
 217   3          }
 218   2        }
 219   1        
 220   1        //撞墙
 221   1          if(Snake_x[0] < 0 || Snake_x[0] > 7 || Snake_y[0] < 0 || Snake_y[0] > 7)
 222   1          {
 223   2            Game_over();
 224   2          }
 225   1      }
 226          
 227          
 228          void main()
 229          {
 230   1        Length = 2;
 231   1        Direction = 4;
 232   1        Score = -1;
 233   1        welcome();
 234   1        while(Independent_Key() == 1) //简单模式
 235   1        {
 236   2            Timer0_Init();
 237   2            Speed = 200;
 238   2            rand();
 239   2            KeyNum = Key();
 240   2            Direction_key();
C51 COMPILER V9.54   MAIN                                                                  12/25/2023 21:32:13 PAGE 5   

 241   2            MatrixLED_Init();
 242   2            Refresh();
 243   2            Eat_food();
 244   2            Snake_death();
 245   2        }
 246   1        while(Independent_Key() == 2) //普通模式
 247   1        {
 248   2            Timer0_Init();
 249   2            Speed = 150;
 250   2            rand();
 251   2            KeyNum = Key();
 252   2            Direction_key();
 253   2            MatrixLED_Init();
 254   2            Refresh();
 255   2            Eat_food();
 256   2            Snake_death();
 257   2        }
 258   1        while(Independent_Key() == 3) //困难模式
 259   1        {
 260   2            Timer0_Init();
 261   2            Speed = 100;
 262   2            rand();
 263   2            KeyNum = Key();
 264   2            Direction_key();
 265   2            MatrixLED_Init();
 266   2            Refresh();
 267   2            Eat_food();
 268   2            Snake_death();
 269   2        }
 270   1        while(Independent_Key() == 4) //娱乐模式
 271   1        {
 272   2            Timer0_Init();
 273   2            Speed = 150;
 274   2            rand();
 275   2            KeyNum = Key();
 276   2            Direction_key();
 277   2            MatrixLED_Init();
 278   2            Refresh();
 279   2            Eat_food();
 280   2            Snake_death();
 281   2        }
 282   1      }
 283          
 284          
 285          void Routine_Timer0() interrupt 1
 286          {
 287   1          static unsigned int T0_Count1,T0_Count2,T0_Count3;
 288   1          TL0 = 0x18;   
 289   1          TH0 = 0xFC;     
 290   1          //刷新按键
 291   1          T0_Count1++;
 292   1          if(T0_Count1 == 50)
 293   1          {
 294   2            T0_Count1 = 0;
 295   2            Circulate_MatrixKey();
 296   2          }
 297   1          //蛇移动的刷新速度
 298   1          T0_Count2++;
 299   1          if(T0_Count2 == Speed)
 300   1          { 
 301   2            T0_Count2 = 0;
 302   2            Snake_move();
C51 COMPILER V9.54   MAIN                                                                  12/25/2023 21:32:13 PAGE 6   

 303   2          }
 304   1          //娱乐模式食物刷新
 305   1          if(Independent_Key() == 4)
 306   1          {
 307   2            T0_Count3++;
 308   2            if(T0_Count3 == 5000)
 309   2            {
 310   3              T0_Count3 = 0;    
 311   3              Food_coordinate();
 312   3              MatrixLED_ShowMove(x[Food_x],y[Food_y]);    
 313   3            }
 314   2          }
 315   1        } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    995    ----
   CONSTANT SIZE    =    376    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
