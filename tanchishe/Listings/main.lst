C51 COMPILER V9.54   MAIN                                                                  12/24/2023 23:51:11 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.l
                    -st) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include <stdlib.h>
   3          #include "Delay.h"
   4          #include "MatrixLED.h"
   5          #include "MatrixKey.h"
   6          #include "Timer0.h"
   7          
   8          unsigned char Direction,Length,KeyNum,Speed,Score;
   9          char Snake_x[11] = {0};//蛇身x坐标,理想状态是64，但单片机RAM不够，所以少设一些
  10          char Snake_y[11] = {0};//蛇身y坐标
  11          unsigned char code x[] = {0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe};
  12          unsigned char code y[] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
  13          unsigned char Food_x;//食物x坐标
  14          unsigned char Food_y;//食物y坐标
  15          
  16          
  17          unsigned char Independent_Key() //四个独立按键选择模式
  18          {
  19   1        static unsigned char KeyNumber_0;
  20   1        if(P3_1==0){KeyNumber_0=1;} //简单模式
  21   1        if(P3_0==0){KeyNumber_0=2;} //普通模式
  22   1        if(P3_2==0){KeyNumber_0=3;} //困难模式
  23   1        if(P3_3==0){KeyNumber_0=4;} //娱乐模式
  24   1        return KeyNumber_0;
  25   1      }
  26          
  27          
  28          void welcome()
  29          {
  30   1          unsigned char code welcome[]={
  31   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  32   1      0x00,0x40,0xC0,0xC0,0xCE,0x71,0x01,0x09,
  33   1      0x16,0x20,0x10,0x18,0x09,0x0A,0x0A,0x04,
  34   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  35   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  36   1      0x32,0x49,0x49,0x49,0x26,0x00,0x41,0x7F,
  37   1      0x41,0x00,0x7F,0x20,0x10,0x10,0x20,0x7F,
  38   1      0x00,0x7F,0x48,0x48,0x48,0x30,0x00,0x7F,
  39   1      0x01,0x01,0x01,0x00,0x7F,0x49,0x49,0x41,
  40   1      0x00,0x22,0x00,0x21,0x7F,0x01,0x00,0xFF,
  41   1      0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,0x7F,
  42   1      0x48,0x4C,0x4A,0x31,0x00,0x7F,0x41,0x41,
  43   1      0x41,0x3E,0x00,0x41,0x7F,0x41,0x00,0x7F,
  44   1      0x20,0x1C,0x02,0x7F,0x00,0x0F,0x34,0x44,
  45   1      0x34,0x0F,0x00,0x7F,0x48,0x4C,0x4A,0x31,
  46   1      0x00,0x40,0x20,0x1F,0x20,0x40,0x00,0x22,
  47   1      0x00,0x23,0x47,0x4D,0x59,0x31,0x00,0xFF,
  48   1      0x00,0x7F,0x41,0x41,0x41,0x3E,0x00,0x41,
  49   1      0x7F,0x41,0x00,0x7F,0x48,0x48,0x40,0x00,
  50   1      0x7F,0x48,0x48,0x40,0x00,0x41,0x7F,0x41,
  51   1      0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x7E,
  52   1      0x01,0x01,0x01,0x7E,0x00,0x7F,0x01,0x01,
  53   1      0x01,0x01,0x40,0x40,0x7F,0x40,0x40,0x00,
  54   1      0x40,0x20,0x1F,0x20,0x40,0x00,0x22,0x00,
C51 COMPILER V9.54   MAIN                                                                  12/24/2023 23:51:11 PAGE 2   

  55   1      0x22,0x41,0x49,0x49,0x36,0x00,0xFF,0x00,
  56   1      0x7F,0x49,0x49,0x41,0x00,0x7F,0x20,0x1C,
  57   1      0x02,0x7F,0x00,0x40,0x40,0x7F,0x40,0x40,
  58   1      0x00,0x7F,0x49,0x49,0x41,0x00,0x7F,0x48,
  59   1      0x4C,0x4A,0x31,0x00,0x40,0x40,0x7F,0x40,
  60   1      0x40,0x00,0x0F,0x34,0x44,0x34,0x0F,0x00,
  61   1      0x41,0x7F,0x41,0x00,0x7F,0x20,0x1C,0x02,
  62   1      0x7F,0x00,0x7F,0x20,0x10,0x10,0x20,0x7F,
  63   1      0x00,0x7F,0x49,0x49,0x41,0x00,0x7F,0x20,
  64   1      0x1C,0x02,0x7F,0x00,0x40,0x40,0x7F,0x40,
  65   1      0x40,0x00,0x22,0x00,0x0C,0x34,0x7F,0x04,
  66   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
  67   1      };
  68   1        unsigned char i,Offset = 0,Count = 0;
  69   1        MatrixLED_Init(); 
  70   1        while(1)  
  71   1        {
  72   2          {
  73   3            for(i = 0;i < 8;i++)
  74   3            {
  75   4              MatrixLED_Show_Gameover(i,welcome[i + Offset]);
  76   4            }
  77   3            Count++;
  78   3            if(Count > 8)
  79   3            {
  80   4              Count = 0;
  81   4              Offset++;
  82   4              if(Offset > 280)
  83   4              {
  84   5                Offset = 0;
  85   5              }
  86   4            }     
  87   3          }
  88   2          if(Independent_Key() == 1 || Independent_Key() == 2 || Independent_Key() == 3 || Independent_Key() == 4)
  89   2          {
  90   3            break;
  91   3          }
  92   2        }
  93   1      }
  94          
  95          
  96          void Snake_move()//蛇身移动
  97          {
  98   1        unsigned char i;
  99   1        for (i = Length + 1; i > 0;i--)
 100   1        {
 101   2            Snake_x[i] = Snake_x[i - 1];//下一次的x坐标为上一次的x坐标，以实现向前挪动
 102   2            Snake_y[i] = Snake_y[i - 1];//同上
 103   2        }
 104   1        switch(Direction)//方向：1:上2:下3:左4:右
 105   1        {
 106   2          case 1:(Snake_y[0])--;break;
 107   2          case 2:(Snake_y[0])++;break;
 108   2          case 3:(Snake_x[0])--;break;
 109   2          case 4:(Snake_x[0])++;break;
 110   2        }
 111   1      }
 112          
 113          
 114          void Direction_key()//检测方向键，控制方向
 115          {
 116   1        if(KeyNum)
C51 COMPILER V9.54   MAIN                                                                  12/24/2023 23:51:11 PAGE 3   

 117   1        {
 118   2          switch(KeyNum){
 119   3            case 1:if(Direction != 1)Direction = 2;break;//如果方向不是上，也就是方向为左或右，那么朝下
 120   3            case 2:if(Direction != 2)Direction = 1;break;//同上
 121   3            case 3:if(Direction != 3)Direction = 4;break;//同上
 122   3            case 4:if(Direction != 4)Direction = 3;break;//同上
 123   3          }     
 124   2        }
 125   1      }
 126          
 127          
 128          void Food_coordinate()//食物坐标
 129          { 
 130   1        Food_x = rand() % 8;
 131   1        Food_y = rand() % 8;
 132   1      }
 133          
 134          
 135          void Refresh() //刷新蛇和食物的位置
 136          {
 137   1        unsigned char i;
 138   1        for(i = 0;i < Length;i++)
 139   1          {
 140   2            MatrixLED_Init();
 141   2            MatrixLED_ShowColumn(x[Snake_x[i]],y[Snake_y[i]]);
 142   2            MatrixLED_Init();
 143   2            MatrixLED_ShowColumn(x[Food_x],y[Food_y]);
 144   2          }
 145   1      }
 146          
 147          
 148          void Eat_food() //判断是否吃到食物
 149          {
 150   1        unsigned char i;
 151   1        for(i = 0;i < Length;i++)
 152   1        {
 153   2          if(Food_x == Snake_x[i] && Food_y == Snake_y[i])
 154   2          {
 155   3            Length++;
 156   3            Food_coordinate();
 157   3            Score++;
 158   3          }
 159   2        }
 160   1      }
 161          
 162          
 163          void Game_over() //游戏结束显示效果
 164          {
 165   1        unsigned char code Animation[] = {
 166   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 167   1      0x7E,0x81,0x81,0x89,0x89,0x4E,0x00,0x1F,
 168   1      0x68,0x88,0x68,0x1F,0x00,0xFF,0x40,0x20,
 169   1      0x20,0x40,0xFF,0x00,0xFF,0x91,0x91,0x91,
 170   1      0x91,0x00,0x00,0x7E,0x81,0x81,0x81,0x81,
 171   1      0x7E,0x00,0xF0,0x0E,0x01,0x0E,0xF0,0x00,
 172   1      0xFF,0x91,0x91,0x91,0x91,0x00,0x7F,0x88,
 173   1      0x8C,0x8A,0x71,0x00,0x00,0x00,0x00,0xF2,
 174   1      0x97,0x92,0x02,0xF2,0x12,0x12,0x02,0xF2,
 175   1      0x02,0xF2,0x92,0x92,0x02,0xF2,0x42,0xB2,
 176   1      0x02,0x02,0x02,0xF2,0x02,0x82,0xF2,0x82,
 177   1      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
 178   1      };
C51 COMPILER V9.54   MAIN                                                                  12/24/2023 23:51:11 PAGE 4   

 179   1        unsigned char i,Offset = 0,Count = 0;
 180   1        MatrixLED_Init();
 181   1        while(1)
 182   1        {
 183   2          for(i = 0;i < 8;i++)
 184   2          {
 185   3            MatrixLED_Show_Gameover(i,Animation[i + Offset]);
 186   3          }
 187   2          Count++;
 188   2          if(Count > 4)
 189   2          {
 190   3            Count = 0;
 191   3            Offset++;
 192   3            if(Offset > 88)
 193   3            {
 194   4              Offset = 0;
 195   4            }
 196   3          }
 197   2          if(Score == 0){P2_0 = 1;}
 198   2          if(Score == 1){P2_0 = 0;}
 199   2          if(Score == 2){P2_0 = 0;P2_1 = 0;}
 200   2          if(Score == 3){P2_0 = 0;P2_1 = 0;P2_2 = 0;}
 201   2          if(Score == 4){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;}
 202   2          if(Score == 5){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;P2_4 = 0;}
 203   2          if(Score == 6){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;P2_4 = 0;P2_5 = 0;}
 204   2          if(Score == 7){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;P2_4 = 0;P2_5 = 0;P2_6 = 0;}
 205   2          if(Score == 8){P2_0 = 0;P2_1 = 0;P2_2 = 0;P2_3 = 0;P2_4 = 0;P2_5 = 0;P2_6 = 0;P2_7 = 0;}
 206   2        }   
 207   1      }
 208          
 209          
 210          void Snake_death() //判断死亡
 211          {
 212   1        
 213   1        //撞自己
 214   1        unsigned char i;
 215   1        for(i = 4;i < Length;i++)
 216   1        {
 217   2          if(Snake_x[0] == Snake_x[i] && Snake_y[0] == Snake_y[i])
 218   2          {     
 219   3            Game_over();
 220   3          }
 221   2        }
 222   1        
 223   1        //撞墙
 224   1          if(Snake_x[0] < 0 || Snake_x[0] > 7 || Snake_y[0] < 0 || Snake_y[0] > 7)
 225   1          {
 226   2            Game_over();
 227   2          }
 228   1      }
 229          
 230          
 231          void main()
 232          {
 233   1        Length = 2;
 234   1        Direction = 4;
 235   1        Score = -1;
 236   1        welcome();
 237   1        while(Independent_Key() == 1) //简单模式
 238   1        {
 239   2            Timer0_Init();
 240   2            Speed = 200;
C51 COMPILER V9.54   MAIN                                                                  12/24/2023 23:51:11 PAGE 5   

 241   2            rand();
 242   2            KeyNum = Key();
 243   2            Direction_key();
 244   2            MatrixLED_Init();
 245   2            Refresh();
 246   2            Eat_food();
 247   2            Snake_death();
 248   2        }
 249   1        while(Independent_Key() == 2) //普通模式
 250   1        {
 251   2            Timer0_Init();
 252   2            Speed = 150;
 253   2            rand();
 254   2            KeyNum = Key();
 255   2            Direction_key();
 256   2            MatrixLED_Init();
 257   2            Refresh();
 258   2            Eat_food();
 259   2            Snake_death();
 260   2        }
 261   1        while(Independent_Key() == 3) //困难模式
 262   1        {
 263   2            Timer0_Init();
 264   2            Speed = 100;
 265   2            rand();
 266   2            KeyNum = Key();
 267   2            Direction_key();
 268   2            MatrixLED_Init();
 269   2            Refresh();
 270   2            Eat_food();
 271   2            Snake_death();
 272   2        }
 273   1        while(Independent_Key() == 4) //娱乐模式
 274   1        {
 275   2            Timer0_Init();
 276   2            Speed = 150;
 277   2            rand();
 278   2            KeyNum = Key();
 279   2            Direction_key();
 280   2            MatrixLED_Init();
 281   2            Refresh();
 282   2            Eat_food();
 283   2            Snake_death();
 284   2        }
 285   1      }
 286          
 287          
 288          void Routine_Timer0() interrupt 1
 289          {
 290   1          static unsigned int T0_Count1,T0_Count2,T0_Count3;
 291   1          TL0 = 0x18;   
 292   1          TH0 = 0xFC;     
 293   1          //刷新按键
 294   1          T0_Count1++;
 295   1          if(T0_Count1 == 50)
 296   1          {
 297   2            T0_Count1 = 0;
 298   2            Circulate_MatrixKey();
 299   2          }
 300   1          //蛇移动的刷新速度
 301   1          T0_Count2++;
 302   1          if(T0_Count2 == Speed)
C51 COMPILER V9.54   MAIN                                                                  12/24/2023 23:51:11 PAGE 6   

 303   1          { 
 304   2            T0_Count2 = 0;
 305   2            Snake_move();
 306   2          }
 307   1          //娱乐模式食物刷新
 308   1          if(Independent_Key() == 4)
 309   1          {
 310   2            T0_Count3++;
 311   2            if(T0_Count3 == 5000)
 312   2            {
 313   3              T0_Count3 = 0;    
 314   3              Food_coordinate();
 315   3              MatrixLED_ShowColumn(x[Food_x],y[Food_y]);    
 316   3            }
 317   2          }
 318   1        } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    995    ----
   CONSTANT SIZE    =    400    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
